/// This module defines the settings and configurations for HTTP client
/// resources within the KDEPS framework. It enables the management of
/// HTTP requests, including method specifications, request data, headers,
/// and handling of responses. This module provides functionalities to
/// retrieve and manage HTTP client resources based on their identifiers.
@ModuleInfo { minPklVersion = "0.28.2" }

@go.Package { name = "github.com/kdeps/schema/gen/http" }

open module org.kdeps.pkl.HTTP

extends "Utils.pkl"
import "package://pkg.pkl-lang.org/pkl-go/pkl.golang@0.10.0#/go.pkl"
import "pkl:json"
import "pkl:test"
import "Agent.pkl" as agent
import "PklResource.pkl" as pklres

/// A mapping of resource actionIDs to their associated [ResourceHTTPClient] objects.
/// This mapping is populated from pklres storage.
Resources: Mapping<String, ResourceHTTPClient> = 
    let (recordIds = pklres.getAllRecords("http"))
    if (recordIds != "" && recordIds != "[]")
        let (parseResult = test.catchOrNull(() -> (new json.Parser {}).parse(recordIds)))
        if (parseResult != null && parseResult is Listing)
            new Mapping {
                for (id in parseResult as Listing<String>) {
                    [id] = 
                        let (recordText = pklres.getPklRecord(id, "http"))
                        if (recordText != null && !recordText.text.isEmpty)
                            parseResourceHTTPFromPkl(recordText, id)
                        else
                            new ResourceHTTPClient {}
                }
            }
        else
            new Mapping<String, ResourceHTTPClient> {}
    else
        new Mapping<String, ResourceHTTPClient> {}

/// Class representing an HTTP client resource, which includes details
/// about the HTTP method, URL, request data, headers, and response.
class ResourceHTTPClient {
        /// Regular expression for validating HTTP methods.
        hidden apiMethodRegex = Regex(#"^(?i:(GET|POST|PUT|PATCH|DELETE|HEAD))"#)

        /// Function to check if a given HTTP method is valid.
        hidden isValidHTTPMethod = (str) -> if (str.matches(apiMethodRegex)) true else throw("Error: Invalid HTTP method. The provided HTTP method is not supported. Please use one of the following methods: GET, POST, PUT, PATCH, DELETE, or HEAD.")

        /// The HTTP method to be used for the request.
        Method: String(isValidHTTPMethod)

        /// The URL to which the request will be sent.
        Url: Uri

        /// Optional data to be sent with the request.
        Data: Listing<String>?

        /// A mapping of headers to be included in the request.
        Headers: Mapping<String, String>?

        /// A mapping of parameters to be included in the request.
        Params: Mapping<String, String>?

        /// The response received from the HTTP request.
        Response: ResponseBlock?

        /// The file path where the response body value of this resource is saved
        File: String?

        /// The listing of the item iteration results
        ItemValues: Listing<String>?

        /// A timestamp of when the request was made, represented as an unsigned 64-bit integer.
        Timestamp: Duration?

        /// The timeout duration (in seconds) for the HTTP request. Defaults to 60 seconds.
        TimeoutDuration: Duration? = 60.s
}

/// Class representing the response block of an HTTP request.
/// It contains the body and headers of the response.
class ResponseBlock {
        /// The body of the response.
        Body: String?

        /// A mapping of response headers.
        Headers: Mapping<String, String>?
}

/// Retrieves the [ResourceHTTPClient] associated with the given [actionID].
///
/// If the resource is not found, returns a new [ResourceHTTPClient] with default values.
///
/// [actionID]: The actionID of the resource to retrieve.
/// [ResourceHTTPClient]: The [ResourceHTTPClient] object associated with the resource actionID.
function resource(actionID: String?): ResourceHTTPClient =
  if (actionID != null)
    let (resolvedID = agent.resolveActionID(actionID))
    // First try to get from pre-populated Resources mapping
    if (Resources.getOrNull(resolvedID) != null)
      Resources[resolvedID]
    else
      // Fallback: fetch from pklres and create resource
      let (pklText = pklres.getPklRecord(resolvedID, "http"))
      if (pklText != null && !pklText.text.isEmpty)
        parseResourceHTTPFromPkl(pklText, resolvedID)
      else
        // Return default ResourceHTTPClient for non-existent resources
        new ResourceHTTPClient {}
  else
    // Return default ResourceHTTPClient for null actionID
    new ResourceHTTPClient {}

/// Retrieves the body of the response associated with the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the response body for.
/// [str]: The body of the response from the HTTP request.
function responseBody(actionID: String?): String = 
    let (res = resource(actionID).Response)
    if (res != null && res.Body != null)
        let (body = res.Body)
        if (isBase64(body)) body.base64Decoded else body
    else ""

/// Retrieves the file path containing the response body associated with the specified resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the response body for.
/// Returns the decoded content if the file is Base64-encoded; otherwise, returns the file content as-is.
function file(actionID: String?): String = 
    let (res = resource(actionID).File)
    if (res != null)
        if (isBase64(res)) res.base64Decoded else res
    else ""

/// Retrieves the item iteration responses for the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the item values.
/// [Listing<String>]: A listing of expected item iteration output.
function itemValues(actionID: String?): Listing<String> = 
    let (res = resource(actionID).ItemValues)
    if (res != null)
        res
    else new Listing<String> {}

/// Retrieves the specified response header associated with the resource [actionID].
///
/// [actionID]: The actionID of the resource to retrieve the response header for.
/// [headeractionID]: The name of the header to retrieve.
/// [str]: The value of the specified response header, or an empty string if not found.
function responseHeader(actionID: String?, headeractionID: String?): String =
  if (actionID != null && headeractionID != null)
    let (res = resource(agent.resolveActionID(actionID)).Response)
    if (res != null && res.Headers != null)
      let (headerValue = res.Headers.getOrNull(headeractionID))
      if (headerValue != null)
        if (isBase64(headerValue)) headerValue.base64Decoded else headerValue
      else ""
    else ""
  else ""

/// Parses a PKL record text and extracts the ResourceHTTPClient object for the given resource ID
/// 
/// [pklText]: The PKL content containing the Resources mapping or individual object
/// [resourceId]: The ID of the resource to extract
/// Returns a ResourceHTTPClient object with the parsed values or default values if parsing fails
function parseResourceHTTPFromPkl(pklText: String, resourceId: String): ResourceHTTPClient =
    if (pklText.isEmpty)
        new ResourceHTTPClient {}
    else
        // Try to evaluate the PKL content as a ResourceHTTPClient object
        let (evaluatedHTTP = evaluatePklContent(pklText))
        if (evaluatedHTTP != null)
            evaluatedHTTP
        else
            // Fallback to default ResourceHTTPClient if parsing fails
            new ResourceHTTPClient {}

/// Evaluates PKL content and returns a ResourceHTTPClient object if successful
/// 
/// [pklContent]: The PKL content to evaluate
/// Returns the evaluated ResourceHTTPClient object or null if evaluation fails
function evaluatePklContent(pklContent: String): ResourceHTTPClient? =
    if (pklContent.isEmpty || pklContent.trim().isEmpty)
        null
    else
        // Try to parse as JSON first (common case)
        let (jsonResult = test.catchOrNull(() -> (new json.Parser {}).parse(pklContent)))
        if (jsonResult != null && jsonResult is Mapping)
            parseResourceHTTPFromJson(jsonResult as Mapping<String, Any>)
        else
            // Try to evaluate as PKL object content
            parseResourceHTTPFromPklText(pklContent)

/// Parses ResourceHTTPClient from JSON mapping
function parseResourceHTTPFromJson(jsonData: Mapping<String, Any>): ResourceHTTPClient? =
    new ResourceHTTPClient {
        Method = jsonData.getOrNull("Method") as String? ?? "GET"
        Url = jsonData.getOrNull("Url") as String? ?? ""
        Data = jsonData.getOrNull("Data") as Listing<String>?
        Headers = jsonData.getOrNull("Headers") as Mapping<String, String>?
        Params = jsonData.getOrNull("Params") as Mapping<String, String>?
        Response = parseResponseFromJson(jsonData.getOrNull("Response"))
        File = jsonData.getOrNull("File") as String?
        ItemValues = jsonData.getOrNull("ItemValues") as Listing<String>?
        Timestamp = jsonData.getOrNull("Timestamp") as Duration?
        TimeoutDuration = jsonData.getOrNull("TimeoutDuration") as Duration?
    }

/// Helper function to parse ResponseBlock from JSON
function parseResponseFromJson(responseData: Any?): ResponseBlock? =
    if (responseData != null && responseData is Mapping)
        let (responseMap = responseData as Mapping<String, Any>)
        new ResponseBlock {
            Body = responseMap.getOrNull("Body") as String?
            Headers = responseMap.getOrNull("Headers") as Mapping<String, String>?
        }
    else
        null

/// Parses ResourceHTTPClient from PKL text content
function parseResourceHTTPFromPklText(content: String): ResourceHTTPClient? =
    // Handle simple object formats like: { Method = "GET"; Url = "https://example.com" }
    if (content.trim().startsWith("{") && content.trim().endsWith("}"))
        // Extract content between braces
        let (innerContent = content.trim().drop(1).dropLast(1).trim())
        let (properties = parseProperties(innerContent))
        new ResourceHTTPClient {
            Method = properties.getOrNull("Method") ?? "GET"
            Url = properties.getOrNull("Url") ?? ""
            Headers = parseHeaders(properties.getOrNull("Headers"))
            TimeoutDuration = parseDurationOrNull(properties.getOrNull("TimeoutDuration"))
            File = properties.getOrNull("File")
        }
    else
        null

/// Helper function to parse properties from PKL object content
function parseProperties(content: String): Mapping<String, String> =
    // Parse key-value pairs from semicolon-separated format
    let (cleanContent = content.replaceAll("\n", ";").replaceAll("\r", ""))
    let (pairs = cleanContent.split(";"))
    let (parsedPairs = pairs.map((pair) -> parseKeyValuePair(pair.trim())).filter((entry) -> entry != null && entry.key != null && !entry.key.isEmpty))
    new Mapping<String, String> {
        for (entry in parsedPairs) {
            [entry.key] = entry.value ?? ""
        }
    }

/// Helper to parse a single key-value pair
function parseKeyValuePair(pair: String): ParsedKeyValue? =
    if (pair.isEmpty || !pair.contains("="))
        null
    else
        let (equalIndex = pair.indexOf("="))
        let (key = pair.substring(0, equalIndex).trim().replaceAll("\"", "").replaceAll("'", ""))
        let (value = pair.substring(equalIndex + 1).trim().replaceAll("\"", "").replaceAll("'", ""))
        if (key.isEmpty)
            null
        else
            new ParsedKeyValue { key = key; value = value }

/// Helper class for parsed key-value pairs
class ParsedKeyValue {
    key: String
    value: String
}

/// Helper function to parse headers from string
function parseHeaders(headersStr: String?): Mapping<String, String> =
    if (headersStr == null || headersStr.trim().isEmpty)
        new Mapping<String, String> {}
    else
        // Try to parse as JSON-like format: {"key1": "value1", "key2": "value2"}
        let (trimmed = headersStr.trim())
        if (trimmed.startsWith("{") && trimmed.endsWith("}"))
            parseKeyValuePairs(trimmed.drop(1).dropLast(1))
        else
            new Mapping<String, String> {}

/// Helper function to parse key-value pairs
function parseKeyValuePairs(content: String): Mapping<String, String> =
    // Parse key-value pairs from comma-separated format
    let (cleanContent = content.replaceAll("\n", ",").replaceAll("\r", ""))
    let (pairs = cleanContent.split(","))
    let (parsedPairs = pairs.map((pair) -> parseKeyValuePair(pair.trim())).filter((entry) -> entry != null && entry.key != null && !entry.key.isEmpty))
    new Mapping<String, String> {
        for (entry in parsedPairs) {
            [entry.key] = entry.value ?? ""
        }
    }

/// Helper function to parse integer with default value
function parseIntOrDefault(value: String?, defaultValue: Int): Int =
    if (value == null || value.trim().isEmpty)
        defaultValue
    else
        let (trimmed = value.trim())
        if (trimmed.matches(Regex("^-?\\d+$")))
            trimmed.toInt()
        else
            defaultValue

/// Helper function to parse duration with null default
function parseDurationOrNull(value: String?): Duration? =
    if (value == null || value.trim().isEmpty)
        null
    else
        let (trimmed = value.trim())
        // Try to parse common duration formats
        if (trimmed.endsWith("s"))
            let (numberPart = trimmed.dropLast(1))
            if (numberPart.matches(Regex("^\\d+$")))
                numberPart.toInt().s
            else
                null
        else if (trimmed.endsWith("ms"))
            let (numberPart = trimmed.dropLast(2))
            if (numberPart.matches(Regex("^\\d+$")))
                numberPart.toInt().ms
            else
                null
        else if (trimmed.matches(Regex("^\\d+$")))
            // Default to seconds if just a number
            trimmed.toInt().s
        else
            null
