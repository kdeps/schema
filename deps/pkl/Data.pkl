/// Abstractions for Data folder
@ModuleInfo { minPklVersion = "0.28.2" }

@go.Package { name = "github.com/kdeps/schema/gen/data" }

open module org.kdeps.pkl.Data

extends "Utils.pkl"
import "package://pkg.pkl-lang.org/pkl-go/pkl.golang@0.10.0#/go.pkl"
import "pkl:json"
import "pkl:test"
import "PklResource.pkl" as pklres

Files: Mapping<String, Mapping<String, String>> =
  let (recordIds = pklres.getAllRecords("data"))
  if (recordIds.length > 0)
    new Mapping {
      for (id in recordIds) {
        [id] = 
          let (recordObject = pklres.getPklRecord(id, "data"))
          if (recordObject != null && !recordObject.text.isEmpty)
            parseDataMappingFromPkl(recordObject.text, id)
          else
            new Mapping<String, String> {}
      }
    }
  else
    new Mapping<String, Mapping<String, String>> {}

/// Parses a PKL record text and extracts the data mapping for the given resource ID
/// 
/// [pklText]: The PKL content containing the Files mapping or individual object
/// [resourceId]: The ID of the resource to extract
/// Returns a Mapping<String, String> with the parsed values or empty mapping if parsing fails
function parseDataMappingFromPkl(pklText: String, resourceId: String): Mapping<String, String> =
    if (pklText.isEmpty)
        new Mapping<String, String> {}
    else
        // Try to evaluate the PKL content as a Mapping<String, String>
        let (evaluatedMapping = evaluatePklContent(pklText))
        if (evaluatedMapping != null)
            evaluatedMapping
        else
            // Fallback to empty mapping if parsing fails
            new Mapping<String, String> {}

/// Evaluates PKL content and returns a Mapping<String, String> if successful
/// 
/// [pklContent]: The PKL content to evaluate
/// Returns the evaluated Mapping<String, String> or null if evaluation fails
function evaluatePklContent(pklContent: String): Mapping<String, String>? =
    if (pklContent.isEmpty || pklContent.trim().isEmpty)
        null
    else
        // Try to parse as JSON first (common case)
        let (jsonResult = test.catchOrNull(() -> (new json.Parser {}).parse(pklContent)))
        if (jsonResult != null && jsonResult is Mapping)
            jsonResult as Mapping<String, String>
        else
            // Try to evaluate as a simple key-value mapping
            parseSimpleMapping(pklContent)

/// Parses simple key-value mappings from PKL content
function parseSimpleMapping(content: String): Mapping<String, String>? =
    // Handle simple mapping formats like: { "key1" = "value1"; "key2" = "value2" }
    if (content.trim().startsWith("{") && content.trim().endsWith("}"))
        // Extract content between braces
        let (innerContent = content.trim().drop(1).dropLast(1).trim())
        if (innerContent.isEmpty)
            new Mapping<String, String> {}
        else
            parseKeyValuePairs(innerContent)
    else
        null

/// Parses key-value pairs from string content
function parseKeyValuePairs(content: String): Mapping<String, String> =
    // Parse key-value pairs from semicolon-separated format
    let (cleanContent = content.replaceAll("\n", ";").replaceAll("\r", ""))
    let (pairs = cleanContent.split(";"))
    let (parsedPairs = pairs.map((pair) -> parseKeyValuePair(pair.trim())).filter((entry) -> entry != null && entry.key != null && !entry.key.isEmpty))
    new Mapping<String, String> {
        for (entry in parsedPairs) {
            [entry.key] = entry.value ?? ""
        }
    }

/// Helper to parse a single key-value pair
function parseKeyValuePair(pair: String): ParsedKeyValue? =
    if (pair.isEmpty || !pair.contains("="))
        null
    else
        let (equalIndex = pair.indexOf("="))
        let (key = pair.substring(0, equalIndex).trim().replaceAll("\"", "").replaceAll("'", ""))
        let (value = pair.substring(equalIndex + 1).trim().replaceAll("\"", "").replaceAll("'", ""))
        if (key.isEmpty)
            null
        else
            new ParsedKeyValue { key = key; value = value }

/// Helper class for parsed key-value pairs
class ParsedKeyValue {
    key: String
    value: String
}
